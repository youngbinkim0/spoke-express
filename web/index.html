<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spoke Express</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 600px;
      margin: 0 auto;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    h1 {
      font-size: 1.5rem;
      font-weight: 600;
    }

    .nav-links {
      display: flex;
      gap: 16px;
    }

    .nav-links a {
      color: #888;
      text-decoration: none;
      font-size: 0.9rem;
    }

    .nav-links a:hover {
      color: #fff;
    }

    .refresh-btn {
      background: none;
      border: 1px solid #444;
      color: #888;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.2s;
    }

    .refresh-btn:hover {
      border-color: #4ecca3;
      color: #4ecca3;
    }

    .refresh-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .weather-bar {
      background: #16213e;
      border-radius: 12px;
      padding: 16px 20px;
      margin-bottom: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .weather-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .weather-temp {
      font-size: 2rem;
      font-weight: 600;
    }

    .weather-conditions {
      color: #888;
    }

    .weather-warning {
      background: #ff6b6b;
      color: #fff;
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 500;
    }

    .time {
      color: #888;
      font-size: 0.9rem;
    }

    .alerts-section {
      margin-bottom: 20px;
    }

    .alert-card {
      background: #ff6b6b22;
      border: 1px solid #ff6b6b;
      border-radius: 8px;
      padding: 12px 16px;
      margin-bottom: 8px;
      font-size: 0.9rem;
      color: #ff6b6b;
    }

    .alert-card.elevator {
      background: #ffc10722;
      border-color: #ffc107;
      color: #ffc107;
    }

    .options-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .option-card {
      background: #16213e;
      border-radius: 12px;
      padding: 16px 20px;
      border-left: 4px solid #4ecca3;
      cursor: pointer;
      transition: background 0.2s;
    }

    .option-card:hover {
      background: #1a3050;
    }

    .option-card.rank-1 {
      background: #1a3a5c;
    }

    .option-card.rank-1:hover {
      background: #1f4268;
    }

    .option-card .expand-icon {
      color: #666;
      font-size: 0.8rem;
      transition: transform 0.2s;
    }

    .option-card.expanded .expand-icon {
      transform: rotate(180deg);
    }

    .option-details-expanded {
      display: none;
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid #2a3f5f;
    }

    .option-card.expanded .option-details-expanded {
      display: block;
    }

    .transfer-step {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 10px 0;
      border-bottom: 1px solid #1a2a4a;
    }

    .transfer-step:last-child {
      border-bottom: none;
    }

    .transfer-step-icon {
      width: 36px;
      text-align: center;
      flex-shrink: 0;
    }

    .transfer-step-info {
      flex: 1;
    }

    .transfer-step-line {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .transfer-step-stops {
      font-size: 0.85rem;
      color: #aaa;
    }

    .transfer-step-time {
      font-size: 0.85rem;
      color: #4ecca3;
      text-align: right;
      flex-shrink: 0;
    }

    .option-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 12px;
    }

    .option-rank {
      background: #4ecca3;
      color: #1a1a2e;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 0.9rem;
    }

    .option-summary {
      font-size: 1.1rem;
      font-weight: 500;
      flex: 1;
      margin-left: 12px;
    }

    .option-duration {
      font-size: 1.3rem;
      font-weight: 700;
      color: #4ecca3;
    }

    .option-details {
      display: flex;
      gap: 20px;
      color: #888;
      font-size: 0.9rem;
      margin-bottom: 12px;
    }

    .option-legs {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .leg {
      display: flex;
      align-items: center;
      gap: 4px;
      background: #0f3460;
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 0.85rem;
    }

    .leg-icon {
      font-size: 1rem;
    }

    .leg-arrow {
      color: #555;
    }

    .line-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      font-size: 0.75rem;
      font-weight: 700;
      color: #fff;
    }

    .filter-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.85rem;
      color: #888;
      cursor: pointer;
      user-select: none;
    }

    .filter-toggle input {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .filter-toggle:hover {
      color: #fff;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #888;
    }

    .error {
      background: #ff6b6b22;
      border: 1px solid #ff6b6b;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      color: #ff6b6b;
    }

    .no-options {
      text-align: center;
      padding: 40px;
      color: #888;
    }

    .no-options a {
      color: #4ecca3;
    }

    .refresh-info {
      text-align: center;
      margin-top: 20px;
      color: #555;
      font-size: 0.8rem;
    }

    /* MTA line colors */
    .line-1, .line-2, .line-3 { background: #EE352E; }
    .line-4, .line-5, .line-6 { background: #00933C; }
    .line-7 { background: #B933AD; }
    .line-A, .line-C, .line-E { background: #0039A6; }
    .line-B, .line-D, .line-F, .line-M { background: #FF6319; }
    .line-G { background: #6CBE45; }
    .line-J, .line-Z { background: #996633; }
    .line-L { background: #A7A9AC; }
    .line-N, .line-Q, .line-R, .line-W { background: #FCCC0A; color: #000; }
    .line-S { background: #808183; }
  </style>
</head>
<body>
  <script src="auto-select.js"></script>
  <script src="mta-api.js?v=3"></script>
  <div class="container">
    <header>
      <h1>Commute Options</h1>
      <div class="nav-links">
        <label class="filter-toggle">
          <input type="checkbox" id="bikeToggle" checked onchange="refreshNow()">
          üö≤ Bike
        </label>
        <button class="refresh-btn" onclick="refreshNow()">‚Üª Refresh</button>
        <a href="arrivals.html">Live Trains</a>
        <a href="settings.html">Settings</a>
      </div>
    </header>

    <div id="content">
      <div class="loading">Loading...</div>
    </div>

    <div class="refresh-info">
      Auto-refreshes every 30 seconds
    </div>
  </div>

  <script>
    const STORAGE_KEY = 'commuteOptimizerSettings';
    const WEATHER_BASE = 'https://api.openweathermap.org';
    // MTA API is now used via mta-api.js

    let STATIONS = [];

    const lineColors = {
      '1': '#EE352E', '2': '#EE352E', '3': '#EE352E',
      '4': '#00933C', '5': '#00933C', '6': '#00933C',
      '7': '#B933AD',
      'A': '#0039A6', 'C': '#0039A6', 'E': '#0039A6',
      'B': '#FF6319', 'D': '#FF6319', 'F': '#FF6319', 'M': '#FF6319',
      'G': '#6CBE45',
      'J': '#996633', 'Z': '#996633',
      'L': '#A7A9AC',
      'N': '#FCCC0A', 'Q': '#FCCC0A', 'R': '#FCCC0A', 'W': '#FCCC0A',
      'S': '#808183',
    };

    function normalizeUrl(url) {
      if (!url) return url;
      if (!/^https?:\/\//i.test(url)) {
        url = 'https://' + url;
      }
      return url.replace(/\/+$/, '');
    }

    function loadSettings() {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (!saved) return null;
      const settings = JSON.parse(saved);
      if (settings.workerUrl) settings.workerUrl = normalizeUrl(settings.workerUrl);
      return settings;
    }

    async function loadStations() {
      try {
        const response = await fetch('stations.json');
        const data = await response.json();
        STATIONS = data.stations || data;  // Handle wrapped or raw array format
      } catch (e) {
        console.error('Failed to load stations:', e);
        STATIONS = [];
      }
    }

    function getStation(id) {
      return STATIONS.find(s => s.id === id);
    }

    function findNearestStation(lat, lng) {
      if (!lat || !lng || STATIONS.length === 0) return null;
      let nearest = null;
      let minDist = Infinity;
      for (const station of STATIONS) {
        const dist = calculateDistance(lat, lng, station.lat, station.lng);
        if (dist < minDist) {
          minDist = dist;
          nearest = station;
        }
      }
      return nearest;
    }

    function calculateDistance(lat1, lng1, lat2, lng2) {
      const R = 3959;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLng/2) * Math.sin(dLng/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    function estimateBikeTime(fromLat, fromLng, toLat, toLng) {
      const distance = calculateDistance(fromLat, fromLng, toLat, toLng);
      const BIKE_SPEED_MPH = 10;
      return Math.ceil((distance / BIKE_SPEED_MPH) * 60 * 1.3);
    }

    function estimateWalkTime(fromLat, fromLng, toLat, toLng) {
      const distance = calculateDistance(fromLat, fromLng, toLat, toLng);
      const WALK_SPEED_MPH = 3;
      return Math.ceil((distance / WALK_SPEED_MPH) * 60 * 1.2);
    }

    async function fetchWeather(lat, lng, apiKey) {
      if (!apiKey) {
        return { tempF: '--', conditions: 'No API key', isBad: false };
      }

      try {
        // Use free 2.5 API (3.0 requires paid subscription)
        const url = `${WEATHER_BASE}/data/2.5/weather?lat=${lat}&lon=${lng}&units=imperial&appid=${apiKey}`;
        const response = await fetch(url);

        if (!response.ok) {
          return { tempF: '--', conditions: 'API error', isBad: false };
        }

        const data = await response.json();
        const weatherId = data.weather?.[0]?.id || 800;
        const conditions = data.weather?.[0]?.main || 'Clear';

        // Weather IDs 200-699 indicate precipitation (rain, snow, etc.)
        const isBad = weatherId >= 200 && weatherId < 700;

        return {
          tempF: Math.round(data.main?.temp || 0),
          conditions,
          precipProb: 0, // 2.5 API doesn't include precipitation probability
          isBad
        };
      } catch (e) {
        return { tempF: '--', conditions: 'Error', isBad: false };
      }
    }

    async function fetchAlerts() {
      if (!window.MtaApi) return [];
      const settings = loadSettings();
      const routeIds = new Set();
      // Use all station lines from auto-selected stations
      const autoStations = (settings.homeLat && settings.workLat && STATIONS.length > 0)
        ? autoSelectStations(settings.homeLat, settings.homeLng, settings.workLat, settings.workLng, STATIONS)
        : [];
      for (const sid of autoStations) {
        const s = getStation(sid);
        if (s) s.lines.forEach(l => routeIds.add(l));
      }
      const dest = findNearestStation(settings.workLat, settings.workLng);
      if (dest) dest.lines.forEach(l => routeIds.add(l));
      try {
        const alerts = await window.MtaApi.fetchServiceAlerts([...routeIds]);
        return alerts
          .filter(a => ['NO_SERVICE', 'REDUCED_SERVICE', 'SIGNIFICANT_DELAYS'].includes(a.effect))
          .slice(0, 3)
          .map(a => ({ text: `${a.routeIds.join('/')} - ${a.headerText}`, isElevator: false }));
      } catch (e) {
        return [];
      }
    }

    async function fetchTransitRoute(originLat, originLng, destLat, destLng, workerUrl, googleKey) {
      // Require both worker URL and API key
      if (!workerUrl || !googleKey) {
        return { error: 'missing_config' };
      }

      try {
        const origin = `${originLat},${originLng}`;
        const dest = `${destLat},${destLng}`;
        const url = `${workerUrl}/directions?origin=${origin}&destination=${dest}&mode=transit&departure_time=now&key=${googleKey}`;

        const response = await fetch(url);
        if (response.ok) {
          const data = await response.json();
          if (data.status === 'OK' && data.durationMinutes) {
            return {
              duration: data.durationMinutes,
              transitSteps: data.transitSteps || [],
              distance: data.distance
            };
          }
        }
        return { error: 'api_error' };
      } catch (e) {
        console.error('Worker error:', e);
        return { error: 'fetch_error' };
      }
    }

    async function fetchNextArrival(stationId, lines) {
      // Use MTA API directly via mta-api.js
      if (window.MtaApi) {
        return await window.MtaApi.getNextArrival(stationId, lines || []);
      }
      return { nextTrain: '--', arrivalTime: '--', routeId: null };
    }

    function rankOptions(options, weather) {
      let sorted = [...options].sort((a, b) => a.duration - b.duration);

      if (weather.isBad) {
        const bikeIdx = sorted.findIndex(o => o.type === 'bike_to_transit');
        const transitIdx = sorted.findIndex(o => o.type === 'transit_only');

        if (bikeIdx === 0 && transitIdx > 0) {
          const transit = sorted.splice(transitIdx, 1)[0];
          sorted.unshift(transit);
        }
      }

      return sorted.map((o, i) => ({ ...o, rank: i + 1 }));
    }

    function getModeIcon(mode) {
      switch (mode) {
        case 'bike': return 'üö≤';
        case 'walk': return 'üö∂';
        case 'subway': return 'üöá';
        default: return '‚Ä¢';
      }
    }

    function cleanLineName(line) {
      if (!line) return '';
      // Remove "Line", "Train", "Express" suffixes and clean up
      let cleaned = line.replace(/\s*(Line|Train|Express|Local)$/i, '').trim();
      // Handle express train suffixes (6X -> 6, 7X -> 7, FX -> F, etc.)
      cleaned = cleaned.replace(/^([A-Z0-9])X$/i, '$1').toUpperCase();
      return cleaned;
    }

    function renderLineBadge(line) {
      const cleanLine = cleanLineName(line);
      const color = lineColors[cleanLine] || '#888';
      const textColor = ['N', 'Q', 'R', 'W'].includes(cleanLine) ? '#000' : '#fff';
      return `<span class="line-badge" style="background:${color};color:${textColor}">${cleanLine}</span>`;
    }

    function renderOption(option) {
      const rankClass = option.rank === 1 ? 'rank-1' : '';

      const legsHtml = option.legs.map((leg, i) => {
        let legContent = `<span class="leg-icon">${getModeIcon(leg.mode)}</span>`;
        if (leg.route) {
          legContent += renderLineBadge(leg.route);
        }
        legContent += ` ${leg.duration}m`;

        const arrow = i < option.legs.length - 1 ? '<span class="leg-arrow">‚Üí</span>' : '';
        return `<span class="leg">${legContent}</span>${arrow}`;
      }).join('');

      // Build expanded details with transfer stops
      const expandedHtml = option.legs.map(leg => {
        const icon = getModeIcon(leg.mode);
        let lineInfo = '';
        let stopsInfo = '';

        if (leg.route) {
          lineInfo = renderLineBadge(leg.route);
          stopsInfo = `${leg.from || ''} ‚Üí ${leg.to}`;
          if (leg.numStops) {
            stopsInfo += ` (${leg.numStops} stops)`;
          }
        } else {
          stopsInfo = `${leg.from || 'Home'} ‚Üí ${leg.to}`;
        }

        return `
          <div class="transfer-step">
            <div class="transfer-step-icon">${icon} ${lineInfo}</div>
            <div class="transfer-step-info">
              <div class="transfer-step-stops">${stopsInfo}</div>
            </div>
            <div class="transfer-step-time">${leg.duration}m</div>
          </div>
        `;
      }).join('');

      return `
        <div class="option-card ${rankClass}" onclick="this.classList.toggle('expanded')">
          <div class="option-header">
            <span class="option-rank">${option.rank}</span>
            <span class="option-summary">${option.summary}</span>
            <span class="option-duration">${option.duration}m <span class="expand-icon">‚ñº</span></span>
          </div>
          <div class="option-details">
            <span>Next train: ${option.nextTrain}</span>
            <span>Arrive: ${option.arrivalTime}</span>
          </div>
          <div class="option-legs">${legsHtml}</div>
          <div class="option-details-expanded">${expandedHtml}</div>
        </div>
      `;
    }

    function renderWeather(weather) {
      const warningHtml = weather.isBad
        ? '<span class="weather-warning">Bad for biking</span>'
        : '';

      return `
        <div class="weather-bar">
          <div class="weather-info">
            <span class="weather-temp">${weather.tempF}¬∞F</span>
            <span class="weather-conditions">${weather.conditions}</span>
            ${warningHtml}
          </div>
          <span class="time">${new Date().toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })}</span>
        </div>
      `;
    }

    function renderAlerts(alerts) {
      if (!alerts || alerts.length === 0) return '';

      return `
        <div class="alerts-section">
          ${alerts.map(a => `
            <div class="alert-card ${a.isElevator ? 'elevator' : ''}">
              ‚ö†Ô∏è ${a.text}
            </div>
          `).join('')}
        </div>
      `;
    }

    async function loadCommute() {
      const content = document.getElementById('content');
      const settings = loadSettings();

      if (!settings || !settings.homeLat || !settings.workLat) {
        content.innerHTML = `
          <div class="no-options">
            Not configured yet.<br>
            <a href="settings.html">Open Settings</a>
          </div>
        `;
        return;
      }

      // Require Google API key and Worker URL for transit routing
      if (!settings.googleKey || !settings.workerUrl) {
        content.innerHTML = `
          <div class="no-options">
            Missing API configuration.<br>
            Please add your <strong>Google API Key</strong> and <strong>Worker URL</strong> in <a href="settings.html">Settings</a>.
          </div>
        `;
        return;
      }

      try {
        // Load stations if not loaded
        if (STATIONS.length === 0) {
          await loadStations();
        }

        // Fetch weather and alerts in parallel
        const [weather, alerts] = await Promise.all([
          fetchWeather(settings.homeLat, settings.homeLng, settings.apiKey),
          fetchAlerts()
        ]);

        // Find nearest station to work location
        const destStation = findNearestStation(settings.workLat, settings.workLng);
        if (!destStation) {
          content.innerHTML = `
            ${renderWeather(weather)}
            <div class="error">Please set your work location in Settings.</div>
          `;
          return;
        }

        const autoSelected = autoSelectStations(
          settings.homeLat, settings.homeLng,
          settings.workLat, settings.workLng,
          STATIONS
        );

        if (autoSelected.length === 0) {
          content.innerHTML = `
            ${renderWeather(weather)}
            ${renderAlerts(alerts)}
            <div class="no-options">
              No stations found within 4 miles of home.
            </div>
          `;
          return;
        }

        // Build commute options
        const options = [];

        // Walk-only option for short commutes
        const homeToWorkDist = calculateDistance(settings.homeLat, settings.homeLng, settings.workLat, settings.workLng);
        if (homeToWorkDist < 2 && settings.workLat && settings.workLng) {
          const walkTime = estimateWalkTime(settings.homeLat, settings.homeLng, settings.workLat, settings.workLng);
          options.push({
            type: 'walk_only',
            summary: 'Walk to Work',
            duration: walkTime,
            nextTrain: 'N/A',
            arrivalTime: new Date(Date.now() + walkTime * 60000).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' }),
            legs: [{ mode: 'walk', duration: walkTime, to: 'Work' }]
          });
        }

        for (const stationId of autoSelected) {
          const station = getStation(stationId);
          if (!station) continue;

          const bikeTime = estimateBikeTime(
            settings.homeLat, settings.homeLng,
            station.lat, station.lng
          );

          const [arrival, transitRoute] = await Promise.all([
            fetchNextArrival(station.mtaId || stationId, station.lines),
            fetchTransitRoute(station.lat, station.lng, destStation.lat, destStation.lng, settings.workerUrl, settings.googleKey)
          ]);

          // Skip if transit routing failed
          if (transitRoute.error) continue;

          const route = arrival.routeId || station.lines[0];
          // Calculate actual arrival time at work
          const waitTime = arrival.minutesAway || 5;
          const totalTime = bikeTime + waitTime + transitRoute.duration;
          const arriveAtWork = new Date(Date.now() + totalTime * 60000)
            .toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });

          // Build legs: bike + transit steps (with transfers)
          const legs = [{ mode: 'bike', duration: bikeTime, to: station.name, from: 'Home' }];
          if (transitRoute.transitSteps && transitRoute.transitSteps.length > 0) {
            // Use detailed transit steps from Routes API
            for (const step of transitRoute.transitSteps) {
              legs.push({
                mode: 'subway',
                duration: step.duration || Math.round(transitRoute.duration / transitRoute.transitSteps.length),
                from: step.departureStop,
                to: step.arrivalStop || 'Work',
                route: step.line,
                numStops: step.numStops
              });
            }
          } else {
            // Fallback: single leg
            legs.push({ mode: 'subway', duration: transitRoute.duration, from: station.name, to: destStation.name, route });
          }

          // Build summary showing all lines (cleaned)
          const linesSummary = transitRoute.transitSteps?.length > 0
            ? transitRoute.transitSteps.map(s => cleanLineName(s.line)).join(' ‚Üí ')
            : route;
          const finalStop = transitRoute.transitSteps?.length > 0
            ? transitRoute.transitSteps[transitRoute.transitSteps.length - 1].arrivalStop
            : destStation.name;

          options.push({
            type: 'bike_to_transit',
            summary: `Bike ‚Üí ${linesSummary} ‚Üí ${finalStop}`,
            duration: totalTime,
            nextTrain: arrival.nextTrain,
            arrivalTime: arriveAtWork,
            legs
          });
        }

        // Transit-only options (walk to station)
        // Generate for closest stations (no walk time limit to ensure at least one option)
        const walkableStations = autoSelected
          .map(id => ({ id, station: getStation(id) }))
          .filter(s => s.station)
          .map(s => ({
            ...s,
            walkTime: estimateWalkTime(settings.homeLat, settings.homeLng, s.station.lat, s.station.lng)
          }))
          .sort((a, b) => a.walkTime - b.walkTime)
          .slice(0, 3); // Top 3 closest for walk options

        for (const { id: stationId, station, walkTime } of walkableStations) {

          const [arrival, transitRoute] = await Promise.all([
            fetchNextArrival(station.mtaId || stationId, station.lines),
            fetchTransitRoute(station.lat, station.lng, destStation.lat, destStation.lng, settings.workerUrl, settings.googleKey)
          ]);

          // Skip if transit routing failed
          if (transitRoute.error) continue;

          const route = arrival.routeId || station.lines[0];
          // Calculate actual arrival time at work
          const waitTime = arrival.minutesAway || 5;
          const totalTime = walkTime + waitTime + transitRoute.duration;
          const arriveAtWork = new Date(Date.now() + totalTime * 60000)
            .toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });

          // Build legs: walk + transit steps (with transfers)
          const legs = [{ mode: 'walk', duration: walkTime, to: station.name, from: 'Home' }];
          if (transitRoute.transitSteps && transitRoute.transitSteps.length > 0) {
            for (const step of transitRoute.transitSteps) {
              legs.push({
                mode: 'subway',
                duration: step.duration || Math.round(transitRoute.duration / transitRoute.transitSteps.length),
                from: step.departureStop,
                to: step.arrivalStop || 'Work',
                route: step.line,
                numStops: step.numStops
              });
            }
          } else {
            legs.push({ mode: 'subway', duration: transitRoute.duration, from: station.name, to: destStation.name, route });
          }

          // Build summary showing all lines (cleaned)
          const linesSummary = transitRoute.transitSteps?.length > 0
            ? transitRoute.transitSteps.map(s => cleanLineName(s.line)).join(' ‚Üí ')
            : route;
          const finalStop = transitRoute.transitSteps?.length > 0
            ? transitRoute.transitSteps[transitRoute.transitSteps.length - 1].arrivalStop
            : destStation.name;

          options.push({
            type: 'transit_only',
            summary: `Walk ‚Üí ${linesSummary} ‚Üí ${finalStop}`,
            duration: totalTime,
            nextTrain: arrival.nextTrain,
            arrivalTime: arriveAtWork,
            legs
          });
        }

        if (options.length === 0) {
          content.innerHTML = `
            ${renderWeather(weather)}
            ${renderAlerts(alerts)}
            <div class="no-options">
              No commute options available.<br>
              Make sure <strong>Google API Key</strong> and <strong>Worker URL</strong> are configured in <a href="settings.html">Settings</a>.
            </div>
          `;
          return;
        }

        // Rank options
        const ranked = rankOptions(options, weather);

        // Check bike toggle
        const showBike = document.getElementById('bikeToggle')?.checked ?? true;
        let filteredOptions = showBike
          ? ranked
          : ranked.filter(o => o.type !== 'bike_to_transit');

        // Ensure at least one non-bike option is shown when bike is enabled
        let topOptions = filteredOptions.slice(0, 5);
        if (showBike) {
          const hasNonBike = topOptions.some(o => o.type !== 'bike_to_transit');
          if (!hasNonBike) {
            const firstNonBike = ranked.find(o => o.type !== 'bike_to_transit');
            if (firstNonBike) {
              topOptions.pop();
              topOptions.push(firstNonBike);
            }
          }
        }

        // Re-rank after filtering
        topOptions = topOptions.map((o, i) => ({ ...o, rank: i + 1 }));

        content.innerHTML = `
          ${renderWeather(weather)}
          ${renderAlerts(alerts)}
          <div class="options-list">
            ${topOptions.map(renderOption).join('')}
          </div>
        `;
      } catch (error) {
        content.innerHTML = `
          <div class="error">
            Failed to load commute options.<br>
            ${error.message}
          </div>
        `;
      }
    }

    async function refreshNow() {
      const btn = document.querySelector('.refresh-btn');
      btn.disabled = true;
      btn.textContent = '‚Üª Loading...';
      await loadCommute();
      btn.disabled = false;
      btn.textContent = '‚Üª Refresh';
    }

    // Load persisted bike toggle setting
    function loadBikeToggleSetting() {
      const settings = loadSettings();
      const bikeToggle = document.getElementById('bikeToggle');
      if (bikeToggle && settings && settings.showBikeOptions !== undefined) {
        bikeToggle.checked = settings.showBikeOptions;
      }
    }

    // Initial load
    loadBikeToggleSetting();
    loadStations().then(loadCommute);

    // Auto-refresh every 30 seconds
    setInterval(loadCommute, 30000);
  </script>
</body>
</html>
