<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spoke Express â€” NYC Bike + Subway Commute Optimizer</title>
  <meta name="description" content="Find the fastest NYC commute by combining bike + subway. Compare walk vs bike to nearby stations with live MTA arrivals and weather-aware routing.">
  <meta name="keywords" content="NYC commute, subway, bike, MTA, transit, real-time arrivals, Manhattan, Brooklyn, Queens">
  <meta property="og:title" content="Spoke Express â€” NYC Bike + Subway Commute Optimizer">
  <meta property="og:description" content="Find the fastest NYC commute by combining bike + subway. Compare walk vs bike to nearby stations with live MTA arrivals and weather-aware routing.">
  <meta property="og:url" content="https://youngbinkim0.github.io/spoke-express/">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Spoke Express â€” NYC Bike + Subway Commute Optimizer">
  <meta name="twitter:description" content="Find the fastest NYC commute by combining bike + subway. Compare walk vs bike to nearby stations with live MTA arrivals and weather-aware routing.">
  <link rel="canonical" href="https://youngbinkim0.github.io/spoke-express/">
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "Spoke Express",
    "description": "Find the fastest NYC commute by combining bike + subway. Compare walk vs bike to nearby stations with live MTA arrivals and weather-aware routing.",
    "url": "https://youngbinkim0.github.io/spoke-express/",
    "applicationCategory": "TravelApplication",
    "operatingSystem": "Web"
  }
  </script>
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link rel="apple-touch-icon" href="icon-192.png">
  <meta name="theme-color" content="#1a1a2e">
  <link rel="stylesheet" href="shared.css">
  <style>
    .options-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .time {
      color: #888;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
<script>
  // Landing page redirect â€” only on direct load (not in-app navigation)
  (function() {
    const isDirectLoad = !document.referrer || !document.referrer.includes(window.location.hostname);
    if (!isDirectLoad) return;
    try {
      const settings = JSON.parse(localStorage.getItem('commuteOptimizerSettings') || '{}');
      const googleKey = settings.googleKey || settings.apiKey;
      if (googleKey) {
        window.location.replace('search.html');
      } else if (!settings.homeLat) {
        window.location.replace('arrivals.html');
      }
    } catch(e) {}
  })();
</script>
  <script src="auto-select.js"></script>
  <script src="mta-api.js?v=3"></script>
  <script src="commute-engine.js"></script>
  <script src="render-utils.js"></script>
  <div class="container">
    <header>
      <h1>My Commute</h1>
      <div class="nav-links">
        <label class="filter-toggle">
          <input type="checkbox" id="bikeToggle" checked onchange="onBikeToggleChanged()">
          ðŸš² Bike
        </label>
        <button class="refresh-btn" onclick="refreshNow()">â†» Refresh</button>
        <a href="search.html">Search</a>
        <a href="arrivals.html">Live Trains</a>
        <a href="settings.html">Settings</a>
      </div>
    </header>

    <div id="content">
      <div class="loading">Loading...</div>
    </div>

    <div class="refresh-info">
      Auto-refreshes every 30 seconds
    </div>
  </div>

  <script>
    async function fetchAlerts() {
      if (!window.MtaApi) return [];
      const settings = loadSettings();
      const routeIds = new Set();
      // Use all station lines from auto-selected stations
      const autoStations = (settings.homeLat && settings.workLat && STATIONS.length > 0)
        ? autoSelectStations(settings.homeLat, settings.homeLng, settings.workLat, settings.workLng, STATIONS)
        : [];
      for (const sid of autoStations) {
        const s = getStation(sid);
        if (s) s.lines.forEach(l => routeIds.add(l));
      }
      const dest = findNearestStation(settings.workLat, settings.workLng);
      if (dest) dest.lines.forEach(l => routeIds.add(l));
      try {
        const alerts = await window.MtaApi.fetchServiceAlerts([...routeIds]);
        return alerts
          .filter(a => ['NO_SERVICE', 'REDUCED_SERVICE', 'SIGNIFICANT_DELAYS'].includes(a.effect))
          .slice(0, 3)
          .map(a => ({ text: `${a.routeIds.join('/')} - ${a.headerText}`, isElevator: false }));
      } catch (e) {
        return [];
      }
    }

    async function loadCommute() {
      const content = document.getElementById('content');
      const settings = loadSettings();

      if (!settings || !settings.homeLat || !settings.workLat) {
        content.innerHTML = `
          <div class="no-options">
            Not configured yet.<br>
            <a href="settings.html">Open Settings</a>
          </div>
        `;
        return;
      }

      // Require Google API key for transit routing
      if (!settings.googleKey) {
        content.innerHTML = `
          <div class="no-options">
            Missing API configuration.<br>
            Please add your <strong>Google API Key</strong> in <a href="settings.html">Settings</a>.
          </div>
        `;
        return;
      }

      try {
        // Load stations if not loaded
        if (STATIONS.length === 0) {
          await loadStations();
        }

        // Fetch weather and alerts in parallel
        const [weather, alerts] = await Promise.all([
          fetchWeather(settings.homeLat, settings.homeLng, settings.googleKey),
          fetchAlerts()
        ]);

        // Find nearest station to work location
        const destStation = findNearestStation(settings.workLat, settings.workLng);
        if (!destStation) {
          content.innerHTML = `
            ${renderWeather(weather)}
            <div class="error">Please set your work location in Settings.</div>
          `;
          return;
        }

        const autoSelected = autoSelectStations(
          settings.homeLat, settings.homeLng,
          settings.workLat, settings.workLng,
          STATIONS
        );

        if (autoSelected.length === 0) {
          content.innerHTML = `
            ${renderWeather(weather)}
            ${renderAlerts(alerts)}
            <div class="no-options">
              No stations found within 4 miles of home.
            </div>
          `;
          return;
        }

        // Build commute options
        const options = [];

        // Walk-only option for short commutes
        const homeToWorkDist = calculateDistance(settings.homeLat, settings.homeLng, settings.workLat, settings.workLng);
        if (homeToWorkDist < 2 && settings.workLat && settings.workLng) {
          const walkTime = estimateWalkTime(settings.homeLat, settings.homeLng, settings.workLat, settings.workLng);
          options.push({
            type: 'walk_only',
            summary: 'Walk to Work',
            duration: walkTime,
            nextTrain: 'N/A',
            arrivalTime: new Date(Date.now() + walkTime * 60000).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' }),
            legs: [{ mode: 'walk', duration: walkTime, to: 'Work' }]
          });
        }

        for (const stationId of autoSelected) {
          const station = getStation(stationId);
          if (!station) continue;

          const bikeTime = estimateBikeTime(
            settings.homeLat, settings.homeLng,
            station.lat, station.lng
          );

          const [arrival, transitRoute] = await Promise.all([
            fetchNextArrival(station.mtaId || stationId, station.lines),
            fetchTransitRoute(station.lat, station.lng, destStation.lat, destStation.lng, WORKER_URL, settings.googleKey)
          ]);

          // Skip if transit routing failed
          if (transitRoute.error) continue;

          const route = arrival.routeId || station.lines[0];
          // Calculate actual arrival time at work
          const waitTime = arrival.minutesAway || 5;
          const totalTime = bikeTime + waitTime + transitRoute.duration;
          const arriveAtWork = new Date(Date.now() + totalTime * 60000)
            .toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });

          // Build legs: bike + transit steps (with transfers)
          const legs = [{ mode: 'bike', duration: bikeTime, to: station.name, from: 'Home' }];
          if (transitRoute.transitSteps && transitRoute.transitSteps.length > 0) {
            // Use detailed transit steps from Routes API
            for (const step of transitRoute.transitSteps) {
              legs.push({
                mode: 'subway',
                duration: step.duration || Math.round(transitRoute.duration / transitRoute.transitSteps.length),
                from: step.departureStop,
                to: step.arrivalStop || 'Work',
                route: step.line,
                numStops: step.numStops
              });
            }
          } else {
            // Fallback: single leg
            legs.push({ mode: 'subway', duration: transitRoute.duration, from: station.name, to: destStation.name, route });
          }

          // Build summary showing all lines (cleaned)
          const linesSummary = transitRoute.transitSteps?.length > 0
            ? transitRoute.transitSteps.map(s => cleanLineName(s.line)).join(' â†’ ')
            : route;
          const finalStop = transitRoute.transitSteps?.length > 0
            ? transitRoute.transitSteps[transitRoute.transitSteps.length - 1].arrivalStop
            : destStation.name;

          options.push({
            type: 'bike_to_transit',
            summary: `Bike â†’ ${linesSummary} â†’ ${finalStop}`,
            duration: totalTime,
            nextTrain: arrival.nextTrain,
            arrivalTime: arriveAtWork,
            legs
          });
        }

        // Transit-only options (walk to station)
        // Generate for closest stations (no walk time limit to ensure at least one option)
        const walkableStations = autoSelected
          .map(id => ({ id, station: getStation(id) }))
          .filter(s => s.station)
          .map(s => ({
            ...s,
            walkTime: estimateWalkTime(settings.homeLat, settings.homeLng, s.station.lat, s.station.lng)
          }))
          .sort((a, b) => a.walkTime - b.walkTime)
          .slice(0, 3); // Top 3 closest for walk options

        for (const { id: stationId, station, walkTime } of walkableStations) {

          const [arrival, transitRoute] = await Promise.all([
            fetchNextArrival(station.mtaId || stationId, station.lines),
            fetchTransitRoute(station.lat, station.lng, destStation.lat, destStation.lng, WORKER_URL, settings.googleKey)
          ]);

          // Skip if transit routing failed
          if (transitRoute.error) continue;

          const route = arrival.routeId || station.lines[0];
          // Calculate actual arrival time at work
          const waitTime = arrival.minutesAway || 5;
          const totalTime = walkTime + waitTime + transitRoute.duration;
          const arriveAtWork = new Date(Date.now() + totalTime * 60000)
            .toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });

          // Build legs: walk + transit steps (with transfers)
          const legs = [{ mode: 'walk', duration: walkTime, to: station.name, from: 'Home' }];
          if (transitRoute.transitSteps && transitRoute.transitSteps.length > 0) {
            for (const step of transitRoute.transitSteps) {
              legs.push({
                mode: 'subway',
                duration: step.duration || Math.round(transitRoute.duration / transitRoute.transitSteps.length),
                from: step.departureStop,
                to: step.arrivalStop || 'Work',
                route: step.line,
                numStops: step.numStops
              });
            }
          } else {
            legs.push({ mode: 'subway', duration: transitRoute.duration, from: station.name, to: destStation.name, route });
          }

          // Build summary showing all lines (cleaned)
          const linesSummary = transitRoute.transitSteps?.length > 0
            ? transitRoute.transitSteps.map(s => cleanLineName(s.line)).join(' â†’ ')
            : route;
          const finalStop = transitRoute.transitSteps?.length > 0
            ? transitRoute.transitSteps[transitRoute.transitSteps.length - 1].arrivalStop
            : destStation.name;

          options.push({
            type: 'transit_only',
            summary: `Walk â†’ ${linesSummary} â†’ ${finalStop}`,
            duration: totalTime,
            nextTrain: arrival.nextTrain,
            arrivalTime: arriveAtWork,
            legs
          });
        }

        if (options.length === 0) {
          content.innerHTML = `
            ${renderWeather(weather)}
            ${renderAlerts(alerts)}
            <div class="no-options">
              No commute options available.<br>
              Make sure <strong>Google API Key</strong> is configured in <a href="settings.html">Settings</a>.
            </div>
          `;
          return;
        }

        // Rank options
        const ranked = rankOptions(options, weather);

        // Check bike toggle
        const showBike = document.getElementById('bikeToggle')?.checked ?? true;
        let filteredOptions = showBike
          ? ranked
          : ranked.filter(o => o.type !== 'bike_to_transit');

        // Ensure at least one non-bike option is shown when bike is enabled
        let topOptions = filteredOptions.slice(0, 5);
        if (showBike) {
          const hasNonBike = topOptions.some(o => o.type !== 'bike_to_transit');
          if (!hasNonBike) {
            const firstNonBike = ranked.find(o => o.type !== 'bike_to_transit');
            if (firstNonBike) {
              topOptions.pop();
              topOptions.push(firstNonBike);
            }
          }
        }

        // Re-rank after filtering
        topOptions = topOptions.map((o, i) => ({ ...o, rank: i + 1 }));

        content.innerHTML = `
          ${renderWeather(weather)}
          ${renderAlerts(alerts)}
          <div class="options-list">
            ${topOptions.map(renderOption).join('')}
          </div>
        `;
      } catch (error) {
        content.innerHTML = `
          <div class="error">
            Failed to load commute options.<br>
            ${error.message}
          </div>
        `;
      }
    }

    async function refreshNow() {
      const btn = document.querySelector('.refresh-btn');
      btn.disabled = true;
      btn.textContent = 'â†» Loading...';
      await loadCommute();
      btn.disabled = false;
      btn.textContent = 'â†» Refresh';
    }

    function persistBikeToggleSetting() {
      const bikeToggle = document.getElementById('bikeToggle');
      if (!bikeToggle) return;
      const settings = loadSettings() || {};
      settings.showBikeOptions = bikeToggle.checked;
      localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
    }

    function onBikeToggleChanged() {
      persistBikeToggleSetting();
      refreshNow();
    }

    // Load persisted bike toggle setting
    function loadBikeToggleSetting() {
      const settings = loadSettings();
      const bikeToggle = document.getElementById('bikeToggle');
      if (bikeToggle && settings && settings.showBikeOptions !== undefined) {
        bikeToggle.checked = settings.showBikeOptions;
      }
    }


    // Initial load
    loadBikeToggleSetting();
    loadStations().then(loadCommute);

    // Auto-refresh every 30 seconds
    setInterval(loadCommute, 30000);
  </script>
</body>
</html>
