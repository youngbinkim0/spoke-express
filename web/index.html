<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NYC Commute Optimizer</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 600px;
      margin: 0 auto;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    h1 {
      font-size: 1.5rem;
      font-weight: 600;
    }

    .nav-links {
      display: flex;
      gap: 16px;
    }

    .nav-links a {
      color: #888;
      text-decoration: none;
      font-size: 0.9rem;
    }

    .nav-links a:hover {
      color: #fff;
    }

    .weather-bar {
      background: #16213e;
      border-radius: 12px;
      padding: 16px 20px;
      margin-bottom: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .weather-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .weather-temp {
      font-size: 2rem;
      font-weight: 600;
    }

    .weather-conditions {
      color: #888;
    }

    .weather-warning {
      background: #ff6b6b;
      color: #fff;
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 500;
    }

    .time {
      color: #888;
      font-size: 0.9rem;
    }

    .alerts-section {
      margin-bottom: 20px;
    }

    .alert-card {
      background: #ff6b6b22;
      border: 1px solid #ff6b6b;
      border-radius: 8px;
      padding: 12px 16px;
      margin-bottom: 8px;
      font-size: 0.9rem;
      color: #ff6b6b;
    }

    .alert-card.elevator {
      background: #ffc10722;
      border-color: #ffc107;
      color: #ffc107;
    }

    .options-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .option-card {
      background: #16213e;
      border-radius: 12px;
      padding: 16px 20px;
      border-left: 4px solid #4ecca3;
    }

    .option-card.rank-1 {
      background: #1a3a5c;
    }

    .option-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 12px;
    }

    .option-rank {
      background: #4ecca3;
      color: #1a1a2e;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 0.9rem;
    }

    .option-summary {
      font-size: 1.1rem;
      font-weight: 500;
      flex: 1;
      margin-left: 12px;
    }

    .option-duration {
      font-size: 1.3rem;
      font-weight: 700;
      color: #4ecca3;
    }

    .option-details {
      display: flex;
      gap: 20px;
      color: #888;
      font-size: 0.9rem;
      margin-bottom: 12px;
    }

    .option-legs {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .leg {
      display: flex;
      align-items: center;
      gap: 4px;
      background: #0f3460;
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 0.85rem;
    }

    .leg-icon {
      font-size: 1rem;
    }

    .leg-arrow {
      color: #555;
    }

    .line-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      font-size: 0.75rem;
      font-weight: 700;
      color: #fff;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #888;
    }

    .error {
      background: #ff6b6b22;
      border: 1px solid #ff6b6b;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      color: #ff6b6b;
    }

    .no-options {
      text-align: center;
      padding: 40px;
      color: #888;
    }

    .no-options a {
      color: #4ecca3;
    }

    .refresh-info {
      text-align: center;
      margin-top: 20px;
      color: #555;
      font-size: 0.8rem;
    }

    /* MTA line colors */
    .line-1, .line-2, .line-3 { background: #EE352E; }
    .line-4, .line-5, .line-6 { background: #00933C; }
    .line-7 { background: #B933AD; }
    .line-A, .line-C, .line-E { background: #0039A6; }
    .line-B, .line-D, .line-F, .line-M { background: #FF6319; }
    .line-G { background: #6CBE45; }
    .line-J, .line-Z { background: #996633; }
    .line-L { background: #A7A9AC; }
    .line-N, .line-Q, .line-R, .line-W { background: #FCCC0A; color: #000; }
    .line-S { background: #808183; }
  </style>
</head>
<body>
  <script src="mta-api.js?v=2"></script>
  <div class="container">
    <header>
      <h1>Commute Options</h1>
      <div class="nav-links">
        <a href="arrivals.html">Live Trains</a>
        <a href="settings.html">Settings</a>
      </div>
    </header>

    <div id="content">
      <div class="loading">Loading...</div>
    </div>

    <div class="refresh-info">
      Auto-refreshes every 30 seconds
    </div>
  </div>

  <script>
    const STORAGE_KEY = 'commuteOptimizerSettings';
    const WEATHER_BASE = 'https://api.openweathermap.org';
    // MTA API is now used via mta-api.js

    let STATIONS = [];

    const lineColors = {
      '1': '#EE352E', '2': '#EE352E', '3': '#EE352E',
      '4': '#00933C', '5': '#00933C', '6': '#00933C',
      '7': '#B933AD',
      'A': '#0039A6', 'C': '#0039A6', 'E': '#0039A6',
      'B': '#FF6319', 'D': '#FF6319', 'F': '#FF6319', 'M': '#FF6319',
      'G': '#6CBE45',
      'J': '#996633', 'Z': '#996633',
      'L': '#A7A9AC',
      'N': '#FCCC0A', 'Q': '#FCCC0A', 'R': '#FCCC0A', 'W': '#FCCC0A',
      'S': '#808183',
    };

    function loadSettings() {
      const saved = localStorage.getItem(STORAGE_KEY);
      return saved ? JSON.parse(saved) : null;
    }

    async function loadStations() {
      try {
        const response = await fetch('stations.json');
        STATIONS = await response.json();
      } catch (e) {
        console.error('Failed to load stations:', e);
        STATIONS = [];
      }
    }

    function getStation(id) {
      return STATIONS.find(s => s.id === id);
    }

    function calculateDistance(lat1, lng1, lat2, lng2) {
      const R = 3959;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLng/2) * Math.sin(dLng/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    function estimateBikeTime(fromLat, fromLng, toLat, toLng) {
      const distance = calculateDistance(fromLat, fromLng, toLat, toLng);
      const BIKE_SPEED_MPH = 10;
      return Math.ceil((distance / BIKE_SPEED_MPH) * 60 * 1.3);
    }

    async function fetchWeather(lat, lng, apiKey) {
      if (!apiKey) {
        return { tempF: '--', conditions: 'No API key', isBad: false };
      }

      try {
        const url = `${WEATHER_BASE}/data/3.0/onecall?lat=${lat}&lon=${lng}&units=imperial&exclude=minutely,daily,alerts&appid=${apiKey}`;
        const response = await fetch(url);

        if (!response.ok) {
          return { tempF: '--', conditions: 'API error', isBad: false };
        }

        const data = await response.json();
        const current = data.current;
        const weatherId = current.weather[0]?.id || 800;
        const conditions = current.weather[0]?.main || 'Clear';
        const precipProb = data.hourly?.[0]?.pop || 0;

        const isBad = (weatherId >= 200 && weatherId < 700) || precipProb > 0.5;

        return {
          tempF: Math.round(current.temp),
          conditions,
          precipProb: Math.round(precipProb * 100),
          isBad
        };
      } catch (e) {
        return { tempF: '--', conditions: 'Error', isBad: false };
      }
    }

    async function fetchAlerts() {
      // MTA service status can be fetched from MTA's service status page
      // For now, we'll return empty as the main alerts require parsing HTML
      // In production, you could use a serverless function or the MTA status API
      return [];
    }

    async function fetchTransitTime(originLat, originLng, destLat, destLng, googleKey) {
      if (!googleKey) {
        // Fallback estimate
        const dist = calculateDistance(originLat, originLng, destLat, destLng);
        return Math.ceil(dist * 4); // Rough estimate: 4 min per mile on subway
      }

      try {
        // Use Google Directions API via CORS proxy or direct if allowed
        const origin = `${originLat},${originLng}`;
        const dest = `${destLat},${destLng}`;

        // Note: Google Directions API doesn't support CORS for browser requests
        // We'll use a fallback calculation for now
        // In production, you'd use a proxy or the Routes API with proper setup

        const dist = calculateDistance(originLat, originLng, destLat, destLng);
        // Better estimate: account for typical subway speed including stops
        const avgSubwaySpeedMph = 17; // Including stops
        return Math.ceil((dist / avgSubwaySpeedMph) * 60);
      } catch (e) {
        const dist = calculateDistance(originLat, originLng, destLat, destLng);
        return Math.ceil(dist * 4);
      }
    }

    async function fetchNextArrival(stationId, lines) {
      // Use MTA API directly via mta-api.js
      if (window.MtaApi) {
        return await window.MtaApi.getNextArrival(stationId, lines || []);
      }
      return { nextTrain: '--', arrivalTime: '--', routeId: null };
    }

    function rankOptions(options, weather) {
      let sorted = [...options].sort((a, b) => a.duration - b.duration);

      if (weather.isBad) {
        const bikeIdx = sorted.findIndex(o => o.type === 'bike_to_transit');
        const transitIdx = sorted.findIndex(o => o.type === 'transit_only');

        if (bikeIdx === 0 && transitIdx > 0) {
          const transit = sorted.splice(transitIdx, 1)[0];
          sorted.unshift(transit);
        }
      }

      return sorted.map((o, i) => ({ ...o, rank: i + 1 }));
    }

    function getModeIcon(mode) {
      switch (mode) {
        case 'bike': return 'üö≤';
        case 'walk': return 'üö∂';
        case 'subway': return 'üöá';
        default: return '‚Ä¢';
      }
    }

    function renderLineBadge(line) {
      const color = lineColors[line] || '#888';
      const textColor = ['N', 'Q', 'R', 'W'].includes(line) ? '#000' : '#fff';
      return `<span class="line-badge" style="background:${color};color:${textColor}">${line}</span>`;
    }

    function renderOption(option) {
      const rankClass = option.rank === 1 ? 'rank-1' : '';

      const legsHtml = option.legs.map((leg, i) => {
        let legContent = `<span class="leg-icon">${getModeIcon(leg.mode)}</span>`;
        if (leg.route) {
          legContent += renderLineBadge(leg.route);
        }
        legContent += ` ${leg.duration}m`;

        const arrow = i < option.legs.length - 1 ? '<span class="leg-arrow">‚Üí</span>' : '';
        return `<span class="leg">${legContent}</span>${arrow}`;
      }).join('');

      return `
        <div class="option-card ${rankClass}">
          <div class="option-header">
            <span class="option-rank">${option.rank}</span>
            <span class="option-summary">${option.summary}</span>
            <span class="option-duration">${option.duration}m</span>
          </div>
          <div class="option-details">
            <span>Next train: ${option.nextTrain}</span>
            <span>Arrive: ${option.arrivalTime}</span>
          </div>
          <div class="option-legs">${legsHtml}</div>
        </div>
      `;
    }

    function renderWeather(weather) {
      const warningHtml = weather.isBad
        ? '<span class="weather-warning">Bad for biking</span>'
        : '';

      return `
        <div class="weather-bar">
          <div class="weather-info">
            <span class="weather-temp">${weather.tempF}¬∞F</span>
            <span class="weather-conditions">${weather.conditions}</span>
            ${warningHtml}
          </div>
          <span class="time">${new Date().toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })}</span>
        </div>
      `;
    }

    function renderAlerts(alerts) {
      if (!alerts || alerts.length === 0) return '';

      return `
        <div class="alerts-section">
          ${alerts.map(a => `
            <div class="alert-card ${a.isElevator ? 'elevator' : ''}">
              ‚ö†Ô∏è ${a.text}
            </div>
          `).join('')}
        </div>
      `;
    }

    async function loadCommute() {
      const content = document.getElementById('content');
      const settings = loadSettings();

      if (!settings || !settings.homeLat || !settings.bikeStations || settings.bikeStations.length === 0) {
        content.innerHTML = `
          <div class="no-options">
            Not configured yet.<br>
            <a href="settings.html">Open Settings</a>
          </div>
        `;
        return;
      }

      try {
        // Load stations if not loaded
        if (STATIONS.length === 0) {
          await loadStations();
        }

        // Fetch weather and alerts in parallel
        const [weather, alerts] = await Promise.all([
          fetchWeather(settings.homeLat, settings.homeLng, settings.apiKey),
          fetchAlerts()
        ]);

        const destStation = getStation(settings.destStation);
        if (!destStation) {
          content.innerHTML = `
            ${renderWeather(weather)}
            <div class="error">Destination station not found. Please reconfigure.</div>
          `;
          return;
        }

        // Build commute options
        const options = [];

        for (const stationId of settings.bikeStations) {
          const station = getStation(stationId);
          if (!station) continue;

          const bikeTime = estimateBikeTime(
            settings.homeLat, settings.homeLng,
            station.lat, station.lng
          );

          const [arrival, transitTime] = await Promise.all([
            fetchNextArrival(stationId, station.lines),
            fetchTransitTime(station.lat, station.lng, destStation.lat, destStation.lng, settings.googleKey)
          ]);

          const route = arrival.routeId || station.lines[0];
          options.push({
            type: 'bike_to_transit',
            summary: `Bike ‚Üí ${route} ‚Üí ${destStation.name}`,
            duration: bikeTime + transitTime,
            nextTrain: arrival.nextTrain,
            arrivalTime: arrival.arrivalTime,
            legs: [
              { mode: 'bike', duration: bikeTime, to: station.name },
              { mode: 'subway', duration: transitTime, to: destStation.name, route }
            ]
          });
        }

        if (options.length === 0) {
          content.innerHTML = `
            ${renderWeather(weather)}
            ${renderAlerts(alerts)}
            <div class="no-options">
              No commute options available.<br>
              <a href="settings.html">Configure stations</a>
            </div>
          `;
          return;
        }

        // Rank options
        const ranked = rankOptions(options, weather);

        content.innerHTML = `
          ${renderWeather(weather)}
          ${renderAlerts(alerts)}
          <div class="options-list">
            ${ranked.slice(0, 5).map(renderOption).join('')}
          </div>
        `;
      } catch (error) {
        content.innerHTML = `
          <div class="error">
            Failed to load commute options.<br>
            ${error.message}
          </div>
        `;
      }
    }

    // Initial load
    loadStations().then(loadCommute);

    // Auto-refresh every 30 seconds
    setInterval(loadCommute, 30000);
  </script>
</body>
</html>
